package com.serviceco.coex.payment.calculation;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.UUID;

import javax.persistence.EntityManager;
import javax.persistence.NonUniqueResultException;
import javax.persistence.PersistenceContext;

import org.apache.commons.collections.CollectionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import com.querydsl.core.types.dsl.BooleanExpression;
import com.querydsl.jpa.impl.JPAQuery;
import com.querydsl.jpa.impl.JPAQueryFactory;
import com.serviceco.coex.crp.model.CRPClaimHeader;
import com.serviceco.coex.crp.model.QCRPClaimHeader;
import com.serviceco.coex.crp.repository.CRPClaimUtilityService;
import com.serviceco.coex.exporter.model.dto.EntryStatus;
import com.serviceco.coex.masterdata.model.HandlingFeeReference;
import com.serviceco.coex.masterdata.model.MaterialType;
import com.serviceco.coex.masterdata.model.QHandlingFeeReference;
import com.serviceco.coex.masterdata.model.QMaterialType;
import com.serviceco.coex.model.DateDimension;
import com.serviceco.coex.model.Scheme;
import com.serviceco.coex.model.dto.Period;
import com.serviceco.coex.payment.model.calculation.PaymentTransactionRec;
import com.serviceco.coex.payment.model.calculation.QPaymentTransactionRec;
import com.serviceco.coex.payment.repository.PaymentTransactionRecRepository;
import com.serviceco.coex.payment.support.DateTimeSupport;
import com.serviceco.coex.scheme.participant.model.MdtParticipantSite;

/**
 * <p>Generates payment transactions for CRP (Container Refund Points) handling fees.</p>
 * 
 * <p>Other CRP payments (scheme paid refunds, cash paid refunds, scheme/cash adjustments) are generated by {@link com.serviceco.coex.payment.calculation.CRPAtypicalPaymentSupportImpl} instead.</p>
 *
 * {@link #getUnprocessedVolume} obtains the available volume data based on CRP claims.
 * {@link #calculateViaActual} generates the payment transactions based on the volume data. 
 *
 * @see com.serviceco.coex.payment.calculation.CRPAtypicalPaymentSupportImpl
 */
@Component
@Transactional
public class CRPPaymentSupportImpl implements CRPPaymentSupport {

  private static final String ALL_SCHEME_PART_IDS = "ALL";

  private static final Logger LOGGER = LoggerFactory.getLogger(CRPPaymentSupportImpl.class);

  @Autowired
  private DateTimeSupport dateTimeSupport;

  @PersistenceContext
  private EntityManager em;

  @Autowired
  private PaymentTransactionRecRepository paymentTransactionRepository;

  @Autowired
  private CRPClaimUtilityService crpClaimUtilityService;

  /**
   * <p>Generates payment transaction records for CRP handling fees based on CRP claims.</p>
   * 
   * <p>The method loops through all volume data linked to the CRP claim header records passed in.</p>
   * <p>A {@link com.serviceco.coex.payment.model.calculation.PaymentTransactionRec} record is created for each one, provided that the gross amount is not zero.</p>
   * <p>The gross amount is calculated as the volume multiplied by a handling fee. The handling fee is obtained from the {@code handlingFeeReference} table based on either:</p>
   * <ul>
   * <li>the CRP ID, material type ID and period start date (preferred)</li>
   * <li>OR a NULL CRP ID, the scheme ID, material type ID and period start date</li>
   * </ul>
   * <p>Any existing {@code PaymentTransactionRec} records matching the scheme participant ID, material type, period type, period, entryType, paymentBatch ID and a status of {@code AWAITING_REVIEW} will be updated to the {@code STALE} status.
   * The new PaymentTransactionRec records include the following data:
   * <ul>
   * <li>Scheme Participant ID = CRP ID</li>
   * <li>Scheme participant name = CRP name</li>
   * <li>Scheme participant type = "CONSUMER"</li>
   * <li>Line type "ITEM"</li>
   * <li>Uom "EA"</li>
   * <li>Status AWAITING_REVIEW</li>
   * <li>Arrear = "N" if the volume period is equal to the current payment period, otherwise "Y"
   * 	<br>(note: it looks like there is a mistake in the code here - I think it should also be "N" if the current period is before the volume period start date)</li>
   * <li>...</li>
   * </ul>
   * 
   * @param param The input calculation data including:
   * @param param.paymentBatch The object which identifies the current batch
   * @param param.currentPeriod The current payment period associated with the volume data and the transactions which are being created
   * @param param.allSalesVolumes The volume (claim) header records
   * @param param.scheme Only transactions created for this scheme will be processed
   * 
   * @return Returns a list of newly created and persisted PaymentTransactionRec records. The handling fee references are also based on this scheme.
   * 
   * @see com.serviceco.coex.payment.calculation.CRPAtypicalPaymentSupportImpl
   * 
   */
  @Override
  public List<PaymentTransactionRec> calculateViaActual(CalculationParameter<CRPClaimHeader> param) {

    final List<PaymentTransactionRec> paymentTransactionRecords = new ArrayList<>();
    final Scheme scheme = param.getScheme();
    for (final CRPClaimHeader header : param.getAllSalesVolumes()) {
      final Period period = dateTimeSupport.periodFactory(header.getPeriod(), header.getPeriodType());
      final Map<String, BigDecimal> materialTypeHeaderVolumes = crpClaimUtilityService.fetchHeaderVolumes(header.getId());
      final boolean isCurrent = param.currentPeriod.getStart().isEqual(period.getStart()) || period.getStart().isBefore(period.getStart());
      final String arrear = isCurrent ? "N" : "Y";

      for (final Entry<String, BigDecimal> materialTypeHeaderVolumeEntry : materialTypeHeaderVolumes.entrySet()) {
        final MdtParticipantSite crp = header.getCrp();
        final String materialTypeId = materialTypeHeaderVolumeEntry.getKey();
        final BigDecimal volume = materialTypeHeaderVolumeEntry.getValue();
        final HandlingFeeReference feeReference = fetchHandlingFeeReference(scheme, crp, materialTypeId, period);
        final BigDecimal fee = (null != feeReference) ? feeReference.getFee() : BigDecimal.ZERO;
        final BigDecimal grossAmount = volume.multiply(fee);
        if (grossAmount.compareTo(BigDecimal.ZERO) == 0) {
          // skip transaction creation for zero amounts;
          continue;
        }
        final BigDecimal taxableAmount = BigDecimal.ZERO;
        final BigDecimal gstAmount = BigDecimal.ZERO;

        /*
         * create payment record
         */
        final QPaymentTransactionRec qPaymentTransactionRec = QPaymentTransactionRec.paymentTransactionRec;

        //@formatter:off
        final List<PaymentTransactionRec> oldPaymentTransactionRecs = getQueryFactory().select(qPaymentTransactionRec)
                                                                                   .from(qPaymentTransactionRec)
                                                                                 .where(qPaymentTransactionRec.schemeParticipantId.eq(header.getCrp().getSiteNumber())
                                                                                  .and(qPaymentTransactionRec.materialType.id.eq(materialTypeId))
                                                                                  .and(qPaymentTransactionRec.periodType.eq(header.getPeriodType().name()))
                                                                                  .and(qPaymentTransactionRec.period.eq(header.getPeriod()))
                                                                                  .and(qPaymentTransactionRec.entryType.eq(header.getEntryType().name()))
                                                                                  .and(qPaymentTransactionRec.paymentBatch.id.ne(param.paymentBatch.getId()))
                                                                                  .and(qPaymentTransactionRec.status.eq(PaymentTransactionRec.PaymentStatus.AWAITING_REVIEW))
                                                                                  .and(qPaymentTransactionRec.scheme.eq(scheme))
                                                                                  ).fetch();
        
        oldPaymentTransactionRecs.stream().forEach(x -> {
          x.setStatus(PaymentTransactionRec.PaymentStatus.STALE);
          paymentTransactionRepository.save(x);
        });
        //@formatter:on

        // TODO : cache this ... otherwise too expensive
        final MaterialType materialType = getQueryFactory().select(QMaterialType.materialType).from(QMaterialType.materialType)
            .where(QMaterialType.materialType.id.eq(materialTypeId)).fetchOne();

        final PaymentTransactionRec paymentTransactionRec = new PaymentTransactionRec();
        paymentTransactionRec.setPaymentType(param.getPaymentMetadata().getTransactionType());
        paymentTransactionRec.setId(UUID.randomUUID().toString());
        paymentTransactionRec.setPaymentBatch(param.paymentBatch);
        paymentTransactionRec.setSchemeParticipantId(header.getCrp().getSiteNumber());
        paymentTransactionRec.setSchemeParticipantName(header.getCrp().getParticipant().getParticipantName());
        paymentTransactionRec.setSchemeParticipantType(param.getSchemeParticipantType().name());
        paymentTransactionRec.setMaterialType(materialType);
        paymentTransactionRec.setPaymentPeriod(param.getCurrentPeriod().toString());
        paymentTransactionRec.setPeriodType(header.getPeriodType().name());
        paymentTransactionRec.setPeriod(header.getPeriod());
        paymentTransactionRec.setEntryType(header.getEntryType().name());
        paymentTransactionRec.setUnitSellingPrice(fee);
        paymentTransactionRec.setArrear(arrear);
        paymentTransactionRec.setGrossAmount(grossAmount);
        paymentTransactionRec.setTaxableAmount(taxableAmount);
        paymentTransactionRec.setGstAmount(gstAmount);
        paymentTransactionRec.setLineType("ITEM");
        paymentTransactionRec.setVolume(volume);
        paymentTransactionRec.setVolumeHeaderId(header.getId());
        paymentTransactionRec.setUom("EA");
        paymentTransactionRec.setPaymentTimestamp(param.paymentBatch.getStartTimeStamp());
        paymentTransactionRec.setStatus(PaymentTransactionRec.PaymentStatus.AWAITING_REVIEW);
        paymentTransactionRec.setScheme(scheme);

        paymentTransactionRepository.save(paymentTransactionRec);
        paymentTransactionRecords.add(paymentTransactionRec);

      }
    }

    return paymentTransactionRecords;
  }

  @Override
  public HandlingFeeReference fetchHandlingFeeReference(final Scheme scheme, final MdtParticipantSite crp, final String materialTypeId, final Period period) {
    try {
      LOGGER.info("fetching handling fee for material type {}, period {}, scheme {}, processor {}", materialTypeId, period, scheme.getName(), crp.getSiteNumber());
      final QHandlingFeeReference feeReference = QHandlingFeeReference.handlingFeeReference;
      final DateDimension effectiveFromDate = dateTimeSupport.correspondingDateDimension(period.getStart());
      final Date periodStartDate = effectiveFromDate.getStartOfDay(scheme);

      //@formatter:off
      HandlingFeeReference reference = getQueryFactory().select(feeReference)
      
                                                      .from(feeReference)
                                                      .where(feeReference.crp.siteNumber.eq(crp.getSiteNumber())
                                                          .and(feeReference.materialType.id.eq(materialTypeId))
                                                       .and(feeReference.effectiveFrom.loe(periodStartDate))
                                                       .and(feeReference.effectiveTo.isNull().or(feeReference.effectiveTo.goe(periodStartDate))))
                                                      .fetchOne();
      if (reference == null) {   
                          reference = getQueryFactory().select(feeReference)
                                        .from(feeReference)
                                        .where(feeReference.materialType.id.eq(materialTypeId)
                                         .and(feeReference.effectiveFrom.loe(periodStartDate))
                                         .and(feeReference.effectiveTo.isNull().or(feeReference.effectiveTo.goe(periodStartDate)))
                                         .and(feeReference.scheme.id.eq(scheme.getId()))
                                         .and(feeReference.crp.isNull()))
                                        .fetchOne();
      }
      //@formatter:on 
      return reference;
    } catch (final NonUniqueResultException exception) {
      throw new RuntimeException(
          exception.getMessage() + " multiple reference data found for period : " + period + " scheme participant " + crp + " material type " + materialTypeId);
    }
  }

  private JPAQueryFactory getQueryFactory() {
    final JPAQueryFactory factory = new JPAQueryFactory(em);
    return factory;
  }

  /**
   * <p>Fetches the available volume data for CRPs.</p>
   * 
   * <p>The CRP volume data is obtained from the {@code cRPClaimHeader} table where the {@code entryStatus} is {@code FINAL}. </p>
   * <p>The CRP volume data records picked up are submitted through the {@link com.serviceco.coex.crp.rest.CRPClaimResource} web service.</p>
   * <p>If the {@code schemeParticipantIds} passed in is not empty and does not contain "ALL", then the records are filtered to those which have a CRP ID that matches a scheme participant ID in {@code schemeParticipantIds}.</p>
   * 
   * @param schemeParticipantIds A list of scheme participant IDs for the participants you want to fetch volume data for. Or, pass an empty list/"ALL" to retrieve volume data for all participants.
   * @return Returns {@link com.serviceco.coex.crp.model.CRPClaimHeader} objects which link to the claim details.  
   * 
   */
  @Override
  public List<CRPClaimHeader> getUnprocessedVolume(List<String> schemeParticipantIds, Scheme scheme) {

    final QCRPClaimHeader qCRPClaimHeader = QCRPClaimHeader.cRPClaimHeader;
    final JPAQuery<CRPClaimHeader> processorClaimVolumesQuery = getQueryFactory().select(qCRPClaimHeader).from(qCRPClaimHeader);
    final BooleanExpression whereClause = qCRPClaimHeader.entryStatus.eq(EntryStatus.FINAL).and(qCRPClaimHeader.scheme.eq(scheme));
    if (CollectionUtils.isNotEmpty(schemeParticipantIds) && !schemeParticipantIds.contains(ALL_SCHEME_PART_IDS)) {
      whereClause.and(qCRPClaimHeader.crp.siteNumber.in(schemeParticipantIds));
    }
    final List<CRPClaimHeader> processorClaimVolumes = processorClaimVolumesQuery.where(whereClause).fetch();

    return processorClaimVolumes;
  }

}
