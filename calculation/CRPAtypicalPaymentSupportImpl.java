package com.serviceco.coex.payment.calculation;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.transaction.Transactional;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.querydsl.jpa.impl.JPAQueryFactory;
import com.serviceco.coex.crp.model.dto.PaymentMethod;
import com.serviceco.coex.exporter.model.dto.EntryType;
import com.serviceco.coex.masterdata.model.MaterialType;
import com.serviceco.coex.model.Scheme;
import com.serviceco.coex.model.dto.Period;
import com.serviceco.coex.payment.model.calculation.CollectionFeeKey;
import com.serviceco.coex.payment.model.calculation.CollectionFeeValue;
import com.serviceco.coex.payment.model.calculation.PaymentBatch;
import com.serviceco.coex.payment.model.calculation.PaymentTransactionRec;
import com.serviceco.coex.payment.model.calculation.QPaymentTransactionRec;
import com.serviceco.coex.payment.model.calculation.QVGstRecoverySchemeTxn;
import com.serviceco.coex.payment.model.calculation.QVRecoveryAmountCashAdjustedTxn;
import com.serviceco.coex.payment.model.calculation.QVRecoveryAmountCashTxn;
import com.serviceco.coex.payment.model.calculation.QVRecoveryAmountSchemeAdjustedTxn;
import com.serviceco.coex.payment.model.calculation.QVRecoveryAmountSchemeTxn;
import com.serviceco.coex.payment.model.calculation.VGstRecoverySchemeTxn;
import com.serviceco.coex.payment.model.calculation.VRecoveryAmountCashAdjustedTxn;
import com.serviceco.coex.payment.model.calculation.VRecoveryAmountCashTxn;
import com.serviceco.coex.payment.model.calculation.VRecoveryAmountSchemeAdjustedTxn;
import com.serviceco.coex.payment.model.calculation.VRecoveryAmountSchemeTxn;
import com.serviceco.coex.payment.repository.PaymentTransactionRecRepository;
import com.serviceco.coex.payment.support.DateTimeSupport;
import com.serviceco.coex.scheme.participant.model.MdtParticipant;
import com.serviceco.coex.scheme.participant.model.MdtParticipantSite;
import com.serviceco.coex.scheme.participant.model.QMdtParticipantSite;
import com.serviceco.coex.util.ReferenceDataUtilityService;
import com.serviceco.coex.util.model.SchemeRefCodes;
import com.serviceco.coex.util.service.SchemeRefCodeService;

/**
 * <p>Generates payment transactions for CRP (Container Refund Points) scheme/cash refunds and adjustments.</p>
 * 
 * <p>CRP handling fees are generated by {@link com.serviceco.coex.payment.calculation.CRPPaymentSupportImpl} instead.</p>
 *
 * {@link #calculateOnTransactionalData} fetches the volume data for each of the different payments &amp; constructs the equivalent payment transaction records. 
 *
 * @see com.serviceco.coex.payment.calculation.CRPPaymentSupportImpl
 */
@Transactional
@Service
public class CRPAtypicalPaymentSupportImpl {

  private static final Logger LOG = LoggerFactory.getLogger(CRPAtypicalPaymentSupportImpl.class);

  private static final String LINE_TYPE = "ITEM";

  private static final String EA = "EA";

  private static final String INELIGIBLE_MATERIAL_TYPE = MaterialType.INELIGIBLE;

  @PersistenceContext
  private EntityManager em;

  @Autowired
  private PaymentTransactionRecRepository paymentRepo;

  @Autowired
  private DateTimeSupport dateTimeSupport;

  @Autowired
  private ReferenceDataUtilityService referenceDataUtilityService;
  
  @Autowired
  private SchemeRefCodeService schemeRefCodeService;

  /**
   * Generates payment transaction records for CRP scheme paid refunds, cash paid refunds, scheme paid adjustments, cash adjustments and GST recovery adjustments.
   * 
   * <p><b>Scheme Payment Refunds:</b><br>
   * For scheme paid refund transactions, the volume data comes from the {@code V_RECOVERY_AMOUNT_CASH_TXN} view, which includes data from {@link com.serviceco.coex.crp.model.CRPClaimHeader}/{@link com.serviceco.coex.crp.model.CRPClaimDetail} records which have not been invoiced and have an entry type of 'R'. Any transactions which did not occur
   * within the same period of a handling fee claim will be filtered out (see handlingFeePeriod). The payment period for these is a week. The
   * payment type is set to "REFUND_AMOUNT" and the payment method is "SCHEME". The unit price used to calculate the gross amount is a hard coded
   * UNIT_SELLING_PRICE (0.090909), for all material types other than INELIGIBLE_MATERIAL_TYPE (MaterialType.INELIGIBLE).
   * </p>
   * 
   * <p>
   * <b>Scheme Payment Adjustments:</b><br>
   * For scheme adjustment transactions, the volume data comes from the {@code V_REC_AMT_SCM_ADJUSTED_TXN} view, which includes data from {@link com.serviceco.coex.crp.model.CRPClaimHeader}/{@link com.serviceco.coex.crp.model.CRPClaimDetail} records which have not been invoiced and have an entry type of 'A'. Any transactions which did not occur
   * within the same period of a handling fee claim will be filtered out (see handlingFeePeriod). Transactions with a zero volume are also filtered out.
   * The payment period for these is a week. The payment type is set to "REFUND_AMOUNT" and the payment method is "SCHEME". The unit price used to calculate the gross amount is a hard coded
   * UNIT_SELLING_PRICE (0.090909) for all material types.
   * </p>
   * 
   * <p>
   * <b>Cash Payments:</b><br>
   * For cash payments, the volume data comes from the V_RECOVERY_AMOUNT_CASH_TXN view, which includes data from the {@link com.serviceco.coex.crp.model.CRPClaimHeader}/{@link com.serviceco.coex.crp.model.CRPClaimDetail} records. Any transactions which did not occur
   * within the same period of a handling fee claim will be filtered out (see {@code handlingFeePeriod}).
   * </p> 
   * 
   * <p>
   * The payment period for these is a week. The payment type is set to "REFUND_AMOUNT" and the payment method is "CASH". The unit price used to calculate the gross amount is a hard coded
   * UNIT_SELLING_PRICE (0.090909) for all material types except for INELIGIBLE_MATERIAL_TYPE (MaterialType.INELIGIBLE). Ineligible materials have a unit price of zero.
   * </p>
   * 
   * <p>
   * <b>Cash Adjustments:</b><br>
   * For cash payment adjustments, the volume data comes from the {@code V_REC_AMT_CASH_ADJUSTED_TXN} view, which includes data from {@link com.serviceco.coex.crp.model.CRPClaimHeader}/{@link com.serviceco.coex.crp.model.CRPClaimDetail} records which have not been invoiced. Any transactions which did not occur
   * within the same period (week) of a handling fee claim will be filtered out (see handlingFeePeriod).
   * </p>
   * 
   * <p>
   * The payment period for these is a week. The payment type is set to "REFUND_AMOUNT" and the payment method is "CASH". The unit price used to calculate the gross amount is a hard coded
   * UNIT_SELLING_PRICE (0.090909) for all material types.
   * </p>
   * 
   * <p>
   * <b>GST payments:</b><br>
   * For GST payments, the volume data comes from {@link com.serviceco.coex.payment.model.calculation.QVGstRecoverySchemeTxn} records. Any transactions which did not occur
   * within the same period (week) of a handling fee claim will be filtered out (see handlingFeePeriod). 
   * 
   * The payment period for these is a week. The payment type is set to "GST_RECOVERY_AMOUNT" and the payment method is "SCHEME". The gross amount for these
   * payments are copied from the {@code gstRecoverySum} field in the QVGstRecoverySchemeTxn records.
   * </p>
   * 
   * @param paymentBatch	The record which identifies the current payment batch. The payment transaction records generated will be linked to this to indicate the batch which created them.
   * @param participantIdList A list of the scheme participants who you are generating payment transactions for. This is not actually used. 
   * @param include This is not used.
   * @param period The current payment period
   * @param handlingFeePeriod Payment periods associated with handling fee claim records found by {@link com.serviceco.coex.payment.calculation.CRPPaymentSupportImpl}, mapped by the scheme participant ID  (CRP ID)
   * @param scheme Only transactions associated with this scheme will be processed
   * @return Returns a list of the {@code com.serviceco.coex.payment.model.calculation.PaymentTransactionRec} records which have been generated
   */
  public List<PaymentTransactionRec> calculateOnTransactionalData(PaymentBatch paymentBatch, List<MdtParticipantSite> participantIdList, boolean include, Period period,
      Map<String, List<Period>> handlingFeePeriod, Scheme scheme) {

    final List<PaymentTransactionRec> paymentTransactionRecords = new ArrayList<>();
    final Period currentPeriod = period;
    final PaymentBatch thisBatch = paymentBatch;

    Map<String, MaterialType> materialTypeMap = referenceDataUtilityService.getMaterialTypes();

    // Preparing a map for caching scheme participants for this run of payment computation
    Map<String, MdtParticipantSite> schemeParticipantMap = new HashMap<>();
    Map<String, Period> periodMap = new HashMap<>();

    BigDecimal crpUnitSellingPrice = getUnitSellingPrice(scheme);
    LOG.info("Considering unit selling price {} for refund amount and collection fee payment transactions.", crpUnitSellingPrice);

    // handle scheme payments - actual ------------------------------------------------------------------

    List<VRecoveryAmountSchemeTxn> recoveryAmountSchemeTxns = handleRecoveryAmountSchemeTxns(handlingFeePeriod, scheme,
        paymentTransactionRecords, currentPeriod, thisBatch, materialTypeMap, schemeParticipantMap, periodMap);

    // handle scheme payments - adjusted ------------------------------------------------------------------
  
    List<VRecoveryAmountSchemeAdjustedTxn> recoveryAmountSchemeAdjTxns = handleRecoveryAmountSchemeAdjustedTxns(
        handlingFeePeriod, scheme, paymentTransactionRecords, currentPeriod, thisBatch, materialTypeMap,
        schemeParticipantMap, periodMap);
   
    // handle cash payments ------------------------------------------------------------------
    
    List<VRecoveryAmountCashTxn> recoveryAmountCashTxns = handleRecoveryAmountCashTxns(handlingFeePeriod, scheme,
        paymentTransactionRecords, currentPeriod, thisBatch, materialTypeMap, schemeParticipantMap, periodMap);

    // handle cash payments - adjusted -----------------------------------------------------------------
    
    List<VRecoveryAmountCashAdjustedTxn> recoveryAmountCashAdjTxns = handleRecoveryAmountCashAdjustedTxns(
        handlingFeePeriod, scheme, paymentTransactionRecords, currentPeriod, thisBatch, materialTypeMap,
        schemeParticipantMap, periodMap);

    // handle gst payments -----------------------------------------------------------------------------------

    handleGstRecoverySchemeTxns(handlingFeePeriod, scheme, paymentTransactionRecords, currentPeriod, thisBatch,
        materialTypeMap, periodMap, crpUnitSellingPrice);

    // handle collection payments
    handleCollectionFees(scheme, paymentTransactionRecords, currentPeriod, thisBatch, materialTypeMap, periodMap,
        recoveryAmountSchemeTxns, recoveryAmountSchemeAdjTxns, recoveryAmountCashTxns,
        recoveryAmountCashAdjTxns);

    return paymentTransactionRecords;

  }

  private void handleCollectionFees(Scheme scheme, final List<PaymentTransactionRec> paymentTransactionRecords,
      final Period currentPeriod, final PaymentBatch thisBatch, Map<String, MaterialType> materialTypeMap,
      Map<String, Period> periodMap, List<VRecoveryAmountSchemeTxn> recoveryAmountSchemeTxns,
      List<VRecoveryAmountSchemeAdjustedTxn> recoveryAmountSchemeAdjTxns,
      List<VRecoveryAmountCashTxn> recoveryAmountCashTxns,
      List<VRecoveryAmountCashAdjustedTxn> recoveryAmountCashAdjTxns) {
    
    String paymentType = PaymentTxnType.COLLECTION_FEES.name();
    
    if (CollectionUtils.isNotEmpty(recoveryAmountSchemeTxns) || CollectionUtils.isNotEmpty(recoveryAmountCashTxns) || CollectionUtils.isNotEmpty(recoveryAmountSchemeAdjTxns)
        || CollectionUtils.isNotEmpty(recoveryAmountCashAdjTxns)) {

      Map<CollectionFeeKey, CollectionFeeValue> collectionFeeForScheme = new HashMap<>();
      if (CollectionUtils.isNotEmpty(recoveryAmountSchemeTxns)) {
        collectionFeeForScheme = recoveryAmountSchemeTxns.stream().collect(Collectors.toMap(new Function<VRecoveryAmountSchemeTxn, CollectionFeeKey>() {

          @Override
          public CollectionFeeKey apply(VRecoveryAmountSchemeTxn t) {

            final CollectionFeeKey collectionFee = new CollectionFeeKey();
            collectionFee.setCrpId(t.getCrpId());
            collectionFee.setMaterialTypeId(t.getMaterialTypeId());
            collectionFee.setTransactionWeek(t.getTransactionWeek());
            return collectionFee;
          }
        }, n1 -> {
          final BigDecimal grossAmountSum = n1.getGrossAmountSum();
          final BigDecimal volume = n1.getVolume();
          return new CollectionFeeValue(grossAmountSum, volume);
        }));
      }
      // recoveryAmountSchemeAdjustedTxns
      Map<CollectionFeeKey, CollectionFeeValue> collectionFeeForSchemeAdj = new HashMap<>();
      if (CollectionUtils.isNotEmpty(recoveryAmountSchemeAdjTxns)) {
        collectionFeeForSchemeAdj = recoveryAmountSchemeAdjTxns.stream().collect(Collectors.toMap(t -> {
          final CollectionFeeKey collectionFee = new CollectionFeeKey();
          collectionFee.setCrpId(t.getCrpId());
          collectionFee.setMaterialTypeId(t.getMaterialTypeId());
          collectionFee.setTransactionWeek(t.getTransactionWeek());
          return collectionFee;
        }, t -> {
          final BigDecimal grossAmountSum = t.getGrossAmountSum();
          final BigDecimal volume = t.getVolume();
          return new CollectionFeeValue(grossAmountSum, volume);
        }));

      }
      // recoveryAmountCashTxns;
      Map<CollectionFeeKey, CollectionFeeValue> collectionFeeForCash = new HashMap<>();
      if (CollectionUtils.isNotEmpty(recoveryAmountCashTxns)) {
        collectionFeeForCash = recoveryAmountCashTxns.stream().collect(Collectors.toMap(new Function<VRecoveryAmountCashTxn, CollectionFeeKey>() {

          @Override
          public CollectionFeeKey apply(VRecoveryAmountCashTxn t) {

            final CollectionFeeKey collectionFee = new CollectionFeeKey();
            collectionFee.setCrpId(t.getCrpId());
            collectionFee.setMaterialTypeId(t.getMaterialTypeId());
            collectionFee.setTransactionWeek(t.getTransactionWeek());
            return collectionFee;
          }
        }, n1 -> {
          final BigDecimal grossAmountSum = n1.getGrossAmountSum();
          final BigDecimal volume = n1.getVolume();
          return new CollectionFeeValue(grossAmountSum, volume);
        }));
      }
      // recoveryAmountCashAdjustedTxns

      Map<CollectionFeeKey, CollectionFeeValue> collectionFeeForCashAdj = new HashMap<>();
      if (CollectionUtils.isNotEmpty(recoveryAmountCashAdjTxns)) {
        collectionFeeForCashAdj = recoveryAmountCashAdjTxns.stream().collect(Collectors.toMap(t -> {
          final CollectionFeeKey collectionFee = new CollectionFeeKey();
          collectionFee.setCrpId(t.getCrpId());
          collectionFee.setMaterialTypeId(t.getMaterialTypeId());
          collectionFee.setTransactionWeek(t.getTransactionWeek());
          return collectionFee;
        }, t -> {
          final BigDecimal grossAmountSum = t.getGrossAmountSum();
          final BigDecimal volume = t.getVolume();
          return new CollectionFeeValue(grossAmountSum, volume);
        }));
      }

      // Combines the gross amount and volume from two CollectionFeeValue's together into a single CollectionFeeValue.
      final BinaryOperator<CollectionFeeValue> combiner = (n1, n2) -> {
        final BigDecimal grossAmountSum = n1.getGrossAmountSum().add(n2.getGrossAmountSum());
        final BigDecimal volume = n1.getVolume().add(n2.getVolume());
        return new CollectionFeeValue(grossAmountSum, volume);
      };

      final Map<CollectionFeeKey, CollectionFeeValue> collectionFeeMapForScheme = merge(collectionFeeForScheme, collectionFeeForSchemeAdj, combiner);
      final Map<CollectionFeeKey, CollectionFeeValue> collectionFeeMapForCash = merge(collectionFeeForCash, collectionFeeForCashAdj, combiner);
      final Map<CollectionFeeKey, CollectionFeeValue> collectionFeeMap = merge(collectionFeeMapForScheme, collectionFeeMapForCash, combiner);

      for (final Map.Entry<CollectionFeeKey, CollectionFeeValue> entry2 : collectionFeeMap.entrySet()) {
        final CollectionFeeKey key = entry2.getKey();
        final CollectionFeeValue value = entry2.getValue();

        final MdtParticipantSite crp = getQueryFactory().select(QMdtParticipantSite.mdtParticipantSite).from(QMdtParticipantSite.mdtParticipantSite)
            .where(QMdtParticipantSite.mdtParticipantSite.siteNumber.eq(key.getCrpId())).fetchOne();

        if (!periodMap.containsKey(key.getTransactionWeek())) {
          Period tempPeriod = Period.parse(key.getTransactionWeek());
          dateTimeSupport.setTerminalDates(tempPeriod);
          periodMap.put(key.getTransactionWeek(), tempPeriod);
        }
        final Period periodForTransaction = periodMap.get(key.getTransactionWeek());
        final String arrear = currentPeriod.getStart().isEqual(periodForTransaction.getStart()) || currentPeriod.getStart().isBefore(periodForTransaction.getStart()) ? "N" : "Y";

        stale(thisBatch, key.getCrpId(), key.getMaterialTypeId(), periodForTransaction, paymentType, "", scheme);

        //@formatter:off
      final PaymentTransactionRec paymentTransactionRec = buildCollecFeesPayment(thisBatch
                                                                     , value
                                                                     , crp
                                                                     , materialTypeMap.get(key.getMaterialTypeId())
                                                                     , periodForTransaction
                                                                     , paymentType
                                                                     , "" // payment method is irrelevant for collection fee... 
                                                                     , currentPeriod
                                                                     , arrear
                                                                     , scheme);
      //@formatter:on
        paymentTransactionRecords.add(paymentRepo.save(paymentTransactionRec));

      }
    }
  }

  private void handleGstRecoverySchemeTxns(Map<String, List<Period>> handlingFeePeriod, Scheme scheme,
      final List<PaymentTransactionRec> paymentTransactionRecords, final Period currentPeriod,
      final PaymentBatch thisBatch, Map<String, MaterialType> materialTypeMap, Map<String, Period> periodMap, 
      BigDecimal crpUnitSellingPrice) {
    final QVGstRecoverySchemeTxn qvGstRecoverySchemeTxn = QVGstRecoverySchemeTxn.vGstRecoverySchemeTxn;
    final List<VGstRecoverySchemeTxn> gstRecoverySchemeTxnsInitial = getQueryFactory().select(qvGstRecoverySchemeTxn).from(qvGstRecoverySchemeTxn)
        .where(qvGstRecoverySchemeTxn.multiSchemeId.eq(scheme.getMultiSchemeId())).fetch();
    List<VGstRecoverySchemeTxn> gstRecoverySchemeTxns = null;

    String paymentType = PaymentTxnType.GST_RECOVERY_AMOUNT.name();
    String paymentMethod = PaymentMethod.SCHEME.name();
    
    /*
     * For GST payments, the volume data comes from QVGstRecoverySchemeTxn records. Any transactions which did not occur
     * within the same period (week) of a handling fee claim will be filtered out (see handlingFeePeriod). 
     * 
     * The payment period for these is a week. The payment type is set to "GST_RECOVERY_AMOUNT" and the payment method is "SCHEME". The gross amount for these
     * payments are set to the 'gstRecoverySum' in the QVGstRecoverySchemeTxn records.
     */
    
    if ((null != gstRecoverySchemeTxnsInitial) && !gstRecoverySchemeTxnsInitial.isEmpty()) {

      gstRecoverySchemeTxns = gstRecoverySchemeTxnsInitial.stream().filter(new Predicate<VGstRecoverySchemeTxn>() {
        @Override
        public boolean test(VGstRecoverySchemeTxn t) {

          final Period thisPeriod = Period.parse(t.getTransactionWeek());
          return handlingFeePeriod.get(t.getCrpId()) != null && handlingFeePeriod.get(t.getCrpId()).contains(thisPeriod);
        }
      }).collect(Collectors.toList());

      final Map<String, List<VGstRecoverySchemeTxn>> gstRecoveryAmountSchemeTxnGroupedByCRP = gstRecoverySchemeTxns.stream()
          .collect(Collectors.groupingBy(VGstRecoverySchemeTxn::getCrpId));
      for (final Map.Entry<String, List<VGstRecoverySchemeTxn>> entry1 : gstRecoveryAmountSchemeTxnGroupedByCRP.entrySet()) {
        final String crpId = entry1.getKey();
        final List<VGstRecoverySchemeTxn> transactions1 = entry1.getValue();

        final MdtParticipantSite crp = getQueryFactory().select(QMdtParticipantSite.mdtParticipantSite).from(QMdtParticipantSite.mdtParticipantSite)
            .where(QMdtParticipantSite.mdtParticipantSite.siteNumber.eq(crpId)).fetchOne();

        // transformation
        final Map<String, List<VGstRecoverySchemeTxn>> gstRecoveryAmountSchemeTxnGroupedByWeek = transactions1.stream()
            .collect(Collectors.groupingBy(VGstRecoverySchemeTxn::getTransactionWeek));
        for (final Map.Entry<String, List<VGstRecoverySchemeTxn>> entry2 : gstRecoveryAmountSchemeTxnGroupedByWeek.entrySet()) {
          final String week = entry2.getKey();
          final List<VGstRecoverySchemeTxn> transactions2 = entry2.getValue();
          for (final VGstRecoverySchemeTxn row : transactions2) {

            if (!periodMap.containsKey(week)) {
              Period tempPeriod = Period.parse(week);
              dateTimeSupport.setTerminalDates(tempPeriod);
              periodMap.put(week, tempPeriod);
            }
            final Period periodForTransaction = periodMap.get(week);
            final String arrear =
                currentPeriod.getStart().isEqual(periodForTransaction.getStart()) || currentPeriod.getStart().isBefore(periodForTransaction.getStart()) ? "N" : "Y";

            stale(thisBatch, crpId, row.getMaterialTypeId(), periodForTransaction, paymentType, paymentMethod, scheme);

            //@formatter:off
          final PaymentTransactionRec paymentTransactionRec = buildPayment(thisBatch
                                                                         , row
                                                                         , crp
                                                                         , materialTypeMap.get(row.getMaterialTypeId())
                                                                         , periodForTransaction
                                                                         , paymentType
                                                                         , paymentMethod
                                                                         , currentPeriod
                                                                         , arrear
                                                                         , scheme);
          //@formatter:on
            paymentTransactionRecords.add(paymentRepo.save(paymentTransactionRec));

          }

        }
      }
    }
  }

  private List<VRecoveryAmountCashAdjustedTxn> handleRecoveryAmountCashAdjustedTxns(
      Map<String, List<Period>> handlingFeePeriod, Scheme scheme,
      final List<PaymentTransactionRec> paymentTransactionRecords, final Period currentPeriod,
      final PaymentBatch thisBatch, Map<String, MaterialType> materialTypeMap,
      Map<String, MdtParticipantSite> schemeParticipantMap, Map<String, Period> periodMap) {
    
    String paymentType = PaymentTxnType.REFUND_AMOUNT.name();
    String paymentMethod = PaymentMethod.CASH.name();
    
    /*
     * For cash payment adjustments, the volume data comes from QVRecoveryAmountCashAdjustedTxn records. Any transactions which did not occur
     * within the same period (week) of a handling fee claim will be filtered out (see handlingFeePeriod). 
     * 
     * The payment period for these is a week. The payment type is set to "REFUND_AMOUNT" and the payment method is "CASH". The unit price used to calculate the gross amount is a hard coded
     * UNIT_SELLING_PRICE (0.090909) for all material types.
     */
    
    final QVRecoveryAmountCashAdjustedTxn qvRecoveryCashAdjTxn = QVRecoveryAmountCashAdjustedTxn.vRecoveryAmountCashAdjustedTxn;
    final List<VRecoveryAmountCashAdjustedTxn> recoveryAmountCashAdjTxnsIntial = getQueryFactory().select(qvRecoveryCashAdjTxn).from(qvRecoveryCashAdjTxn)
        .where(qvRecoveryCashAdjTxn.multiSchemeId.eq(scheme.getMultiSchemeId())).fetch();
    List<VRecoveryAmountCashAdjustedTxn> recoveryAmountCashAdjTxns = null;

    if (CollectionUtils.isNotEmpty(recoveryAmountCashAdjTxnsIntial)) {
      recoveryAmountCashAdjTxns = recoveryAmountCashAdjTxnsIntial.stream().filter(
          t -> handlingFeePeriod.get(t.getCrpId()) != null && handlingFeePeriod.get(t.getCrpId()).contains(Period.parse(t.getTransactionWeek()))
              && t.getVolume() != BigDecimal.ZERO).collect(Collectors.toList());

      final Map<String, List<VRecoveryAmountCashAdjustedTxn>> recoveryAmountCashAdjTxnsGroupedByCrp = recoveryAmountCashAdjTxns.stream()
          .collect(Collectors.groupingBy(VRecoveryAmountCashAdjustedTxn::getCrpId));

      for (final Map.Entry<String, List<VRecoveryAmountCashAdjustedTxn>> entry1 : recoveryAmountCashAdjTxnsGroupedByCrp.entrySet()) {
        final String crpId = entry1.getKey();
        final List<VRecoveryAmountCashAdjustedTxn> transactions1 = entry1.getValue();

        if (!schemeParticipantMap.containsKey(crpId)) {
          MdtParticipantSite tempVal = getQueryFactory().select(QMdtParticipantSite.mdtParticipantSite).from(QMdtParticipantSite.mdtParticipantSite)
              .where(QMdtParticipantSite.mdtParticipantSite.siteNumber.eq(crpId)).fetchOne();

          schemeParticipantMap.put(crpId, tempVal);
        }

        final MdtParticipantSite crp = schemeParticipantMap.get(crpId);

        // transformation
        final Map<String, List<VRecoveryAmountCashAdjustedTxn>> recoveryAmountCashTxnGroupedByWeek = transactions1.stream()
            .collect(Collectors.groupingBy(VRecoveryAmountCashAdjustedTxn::getTransactionWeek));
        for (final Map.Entry<String, List<VRecoveryAmountCashAdjustedTxn>> entry2 : recoveryAmountCashTxnGroupedByWeek.entrySet()) {
          final String week = entry2.getKey();
          final List<VRecoveryAmountCashAdjustedTxn> transactions2 = entry2.getValue();
          for (final VRecoveryAmountCashAdjustedTxn row : transactions2) {

            if (!periodMap.containsKey(week)) {
              Period tempPeriod = Period.parse(week);
              dateTimeSupport.setTerminalDates(tempPeriod);
              periodMap.put(week, tempPeriod);
            }
            final Period periodForTransaction = periodMap.get(week);
            final String arrear =
                currentPeriod.getStart().isEqual(periodForTransaction.getStart()) || currentPeriod.getStart().isBefore(periodForTransaction.getStart()) ? "N" : "Y";

            stale(thisBatch, crpId, row.getMaterialTypeId(), periodForTransaction, paymentType, paymentMethod, scheme);

            // Commenting following code for QCRS-1290
            // Hardcoding at the moment but in future will fetch from new reference table
            /*
             * RefundAmountReference reference = referenceDataUtilityService.fetchRefundAmountReferenceForMaterialType(refundAmountReferences, row.getMaterialTypeId(),
             * effectiveFromDateForCurrentPeriod); if (reference == null) { reference = RefundAmountReference.ZERO_VALUE(); }
             *
             * BigDecimal unitSellingPrice = new BigDecimal(reference.getRefundAmount());
             */

            row.setGrossAmountSum(row.getVolume().multiply(getUnitSellingPrice(scheme)));

            //@formatter:off
            final PaymentTransactionRec paymentTransactionRec = buildRecovAmtCashAdjPayment(thisBatch
                                                                         , row
                                                                         , crp
                                                                         , materialTypeMap.get(row.getMaterialTypeId())
                                                                         , periodForTransaction
                                                                         , paymentType
                                                                         , paymentMethod
                                                                         , currentPeriod
                                                                         , arrear
                                                                         , scheme);
            //@formatter:on
            paymentTransactionRecords.add(paymentRepo.save(paymentTransactionRec));

          }

        }
      }

    }
    return recoveryAmountCashAdjTxns;
  }

  private List<VRecoveryAmountCashTxn> handleRecoveryAmountCashTxns(Map<String, List<Period>> handlingFeePeriod,
      Scheme scheme, final List<PaymentTransactionRec> paymentTransactionRecords, final Period currentPeriod,
      final PaymentBatch thisBatch, Map<String, MaterialType> materialTypeMap,
      Map<String, MdtParticipantSite> schemeParticipantMap, Map<String, Period> periodMap) {
    
    String paymentType = PaymentTxnType.REFUND_AMOUNT.name();
    String paymentMethod = PaymentMethod.CASH.name();
    
    /*
     * For cash payments, the volume data comes from QVRecoveryAmountCashTxn records. Any transactions which did not occur
     * within the same period of a handling fee claim will be filtered out (see handlingFeePeriod). 
     * 
     * The payment period for these is a week. The payment type is set to "REFUND_AMOUNT" and the payment method is "CASH". The unit price used to calculate the gross amount is a hard coded
     * UNIT_SELLING_PRICE (0.090909) for all material types except for INELIGIBLE_MATERIAL_TYPE (MaterialType.INELIGIBLE). Ineligible materials have a unit price of zero.
     * 
     */
    
    final QVRecoveryAmountCashTxn qvRecoveryAmountCashTxn = QVRecoveryAmountCashTxn.vRecoveryAmountCashTxn;
    final List<VRecoveryAmountCashTxn> recoveryAmountCashTxnsInitial = getQueryFactory().select(qvRecoveryAmountCashTxn).from(qvRecoveryAmountCashTxn)
        .where(qvRecoveryAmountCashTxn.multiSchemeId.eq(scheme.getMultiSchemeId())).fetch();
    List<VRecoveryAmountCashTxn> recoveryAmountCashTxns = null;

    if ((null != recoveryAmountCashTxnsInitial) && !recoveryAmountCashTxnsInitial.isEmpty()) {

      recoveryAmountCashTxns = recoveryAmountCashTxnsInitial.stream().filter(new Predicate<VRecoveryAmountCashTxn>() {
        @Override
        public boolean test(VRecoveryAmountCashTxn t) {

          final Period thisPeriod = Period.parse(t.getTransactionWeek());
          return handlingFeePeriod.get(t.getCrpId()) != null && handlingFeePeriod.get(t.getCrpId()).contains(thisPeriod);
        }
      }).collect(Collectors.toList());

      final Map<String, List<VRecoveryAmountCashTxn>> recoveryAmountCashTxnGroupedByCRP = recoveryAmountCashTxns.stream()
          .collect(Collectors.groupingBy(VRecoveryAmountCashTxn::getCrpId));
      for (final Map.Entry<String, List<VRecoveryAmountCashTxn>> entry1 : recoveryAmountCashTxnGroupedByCRP.entrySet()) {
        final String crpId = entry1.getKey();
        final List<VRecoveryAmountCashTxn> transactions1 = entry1.getValue();

        if (!schemeParticipantMap.containsKey(crpId)) {
          MdtParticipantSite tempVal = getQueryFactory().select(QMdtParticipantSite.mdtParticipantSite).from(QMdtParticipantSite.mdtParticipantSite)
              .where(QMdtParticipantSite.mdtParticipantSite.siteNumber.eq(crpId)).fetchOne();

          schemeParticipantMap.put(crpId, tempVal);
        }

        final MdtParticipantSite crp = schemeParticipantMap.get(crpId);

        // transformation
        final Map<String, List<VRecoveryAmountCashTxn>> recoveryAmountCashTxnGroupedByWeek = transactions1.stream()
            .collect(Collectors.groupingBy(VRecoveryAmountCashTxn::getTransactionWeek));
        for (final Map.Entry<String, List<VRecoveryAmountCashTxn>> entry2 : recoveryAmountCashTxnGroupedByWeek.entrySet()) {
          final String week = entry2.getKey();
          final List<VRecoveryAmountCashTxn> transactions2 = entry2.getValue();
          for (final VRecoveryAmountCashTxn row : transactions2) {

            if (!periodMap.containsKey(week)) {
              Period tempPeriod = Period.parse(week);
              dateTimeSupport.setTerminalDates(tempPeriod);
              periodMap.put(week, tempPeriod);
            }
            final Period periodForTransaction = periodMap.get(week);
            final String arrear =
                currentPeriod.getStart().isEqual(periodForTransaction.getStart()) || currentPeriod.getStart().isBefore(periodForTransaction.getStart()) ? "N" : "Y";

            stale(thisBatch, crpId, row.getMaterialTypeId(), periodForTransaction, paymentType, paymentMethod, scheme);
            row.setGrossAmountSum(row.getVolume().multiply(getUnitSellingPrice(scheme, row.getMaterialTypeId())));
            //@formatter:off
          final PaymentTransactionRec paymentTransactionRec = buildRecovCashPayment(thisBatch
                                                                         , row
                                                                         , crp
                                                                         , materialTypeMap.get(row.getMaterialTypeId())
                                                                         , periodForTransaction
                                                                         , paymentType
                                                                         , paymentMethod
                                                                         , currentPeriod
                                                                         , arrear
                                                                         , scheme);
          //@formatter:on
            paymentTransactionRecords.add(paymentRepo.save(paymentTransactionRec));

          }

        }
      }
    }
    return recoveryAmountCashTxns;
  }

  private List<VRecoveryAmountSchemeAdjustedTxn> handleRecoveryAmountSchemeAdjustedTxns(
      Map<String, List<Period>> handlingFeePeriod, Scheme scheme,
      final List<PaymentTransactionRec> paymentTransactionRecords, final Period currentPeriod,
      final PaymentBatch thisBatch, Map<String, MaterialType> materialTypeMap,
      Map<String, MdtParticipantSite> schemeParticipantMap, Map<String, Period> periodMap) {
    
    String paymentType = PaymentTxnType.REFUND_AMOUNT.name();
    String paymentMethod = PaymentMethod.SCHEME.name();
    
    /* For scheme adjustment transactions, the volume data comes from QVRecoveryAmountSchemeAdjustedTxn records. Any transactions which did not occur
     * within the same period of a handling fee claim will be filtered out (see handlingFeePeriod). Transactions with a zero volume are also filtered out.
     * The payment period for these is a week. The payment type is set to "REFUND_AMOUNT" and the payment method is "SCHEME". The unit price used to calculate the gross amount is a hard coded
     * UNIT_SELLING_PRICE (0.090909) for all material types.
     */  
    
    final QVRecoveryAmountSchemeAdjustedTxn qvRecoverySchemeAdjTxn = QVRecoveryAmountSchemeAdjustedTxn.vRecoveryAmountSchemeAdjustedTxn;
    final List<VRecoveryAmountSchemeAdjustedTxn> recoveryAmountSchemeAdjTxnsIntial = getQueryFactory().select(qvRecoverySchemeAdjTxn).from(qvRecoverySchemeAdjTxn)
        .where(qvRecoverySchemeAdjTxn.multiSchemeId.eq(scheme.getMultiSchemeId()))
        .fetch();

    List<VRecoveryAmountSchemeAdjustedTxn> recoveryAmountSchemeAdjTxns = null;
    if (CollectionUtils.isNotEmpty(recoveryAmountSchemeAdjTxnsIntial)) {
      recoveryAmountSchemeAdjTxns = recoveryAmountSchemeAdjTxnsIntial.stream().filter(
          t -> handlingFeePeriod.get(t.getCrpId()) != null && handlingFeePeriod.get(t.getCrpId()).contains(Period.parse(t.getTransactionWeek()))
              && t.getVolume() != BigDecimal.ZERO).collect(Collectors.toList());

      final Map<String, List<VRecoveryAmountSchemeAdjustedTxn>> recoveryAmountSchemeAdjTxnsGroupedByCrp = recoveryAmountSchemeAdjTxns.stream()
          .collect(Collectors.groupingBy(VRecoveryAmountSchemeAdjustedTxn::getCrpId));

      for (final Map.Entry<String, List<VRecoveryAmountSchemeAdjustedTxn>> entry1 : recoveryAmountSchemeAdjTxnsGroupedByCrp.entrySet()) {
        final String crpId = entry1.getKey();
        final List<VRecoveryAmountSchemeAdjustedTxn> transactions1 = entry1.getValue();

        if (!schemeParticipantMap.containsKey(crpId)) {
          MdtParticipantSite tempVal = getQueryFactory().select(QMdtParticipantSite.mdtParticipantSite).from(QMdtParticipantSite.mdtParticipantSite)
              .where(QMdtParticipantSite.mdtParticipantSite.siteNumber.eq(crpId)).fetchOne();

          schemeParticipantMap.put(crpId, tempVal);
        }

        final MdtParticipantSite crp = schemeParticipantMap.get(crpId);

        // transformation
        final Map<String, List<VRecoveryAmountSchemeAdjustedTxn>> recoveryAmountSchemeTxnGroupedByWeek = transactions1.stream()
            .collect(Collectors.groupingBy(VRecoveryAmountSchemeAdjustedTxn::getTransactionWeek));
        for (final Map.Entry<String, List<VRecoveryAmountSchemeAdjustedTxn>> entry2 : recoveryAmountSchemeTxnGroupedByWeek.entrySet()) {
          final String week = entry2.getKey();
          final List<VRecoveryAmountSchemeAdjustedTxn> transactions2 = entry2.getValue();
          for (final VRecoveryAmountSchemeAdjustedTxn row : transactions2) {

            if (!periodMap.containsKey(week)) {
              Period tempPeriod = Period.parse(week);
              dateTimeSupport.setTerminalDates(tempPeriod);
              periodMap.put(week, tempPeriod);
            }
            final Period periodForTransaction = periodMap.get(week);
            final String arrear =
                currentPeriod.getStart().isEqual(periodForTransaction.getStart()) || currentPeriod.getStart().isBefore(periodForTransaction.getStart()) ? "N" : "Y";

            stale(thisBatch, crpId, row.getMaterialTypeId(), periodForTransaction, paymentType, paymentMethod, scheme);

            // Commenting following code for QCRS-1290
            // Hardcoding at the moment but in future will fetch from new reference table
            /*
             * RefundAmountReference reference = referenceDataUtilityService.fetchRefundAmountReferenceForMaterialType(refundAmountReferences, row.getMaterialTypeId(),
             * effectiveFromDateForCurrentPeriod); if (reference == null) { reference = RefundAmountReference.ZERO_VALUE(); }
             *
             * BigDecimal unitSellingPrice = new BigDecimal(reference.getRefundAmount());
             */
            row.setGrossAmountSum(row.getVolume().multiply(getUnitSellingPrice(scheme)));

            //@formatter:off
            final PaymentTransactionRec paymentTransactionRec = buildRocovAmountSchAdjPayment(thisBatch
                                                                         , row
                                                                         , crp
                                                                         , materialTypeMap.get(row.getMaterialTypeId())
                                                                         , periodForTransaction
                                                                         , paymentType
                                                                         , paymentMethod
                                                                         , currentPeriod
                                                                         , arrear
                                                                         , scheme);
            //@formatter:on
            paymentTransactionRecords.add(paymentRepo.save(paymentTransactionRec));

          }

        }
      }

    }
    return recoveryAmountSchemeAdjTxns;
  }

  private List<VRecoveryAmountSchemeTxn> handleRecoveryAmountSchemeTxns(Map<String, List<Period>> handlingFeePeriod,
      Scheme scheme, final List<PaymentTransactionRec> paymentTransactionRecords, final Period currentPeriod,
      final PaymentBatch thisBatch, Map<String, MaterialType> materialTypeMap,
      Map<String, MdtParticipantSite> schemeParticipantMap, Map<String, Period> periodMap) {
    
    String paymentType = PaymentTxnType.REFUND_AMOUNT.name();
    String paymentMethod = PaymentMethod.SCHEME.name();
    
    /* For scheme paid refund transactions, the volume data comes from QVRecoveryAmountSchemeTxn records. Any transactions which did not occur
    * within the same period of a handling fee claim will be filtered out (see handlingFeePeriod). The payment period for these is a week. The
    * payment type is set to "REFUND_AMOUNT" and the payment method is "SCHEME". The unit price used to calculate the gross amount is a hard coded
    * UNIT_SELLING_PRICE (0.090909), for all material types other than INELIGIBLE_MATERIAL_TYPE (MaterialType.INELIGIBLE).
    */
    
    final QVRecoveryAmountSchemeTxn qvRecoveryAmountSchemeTxn = QVRecoveryAmountSchemeTxn.vRecoveryAmountSchemeTxn;
    final List<VRecoveryAmountSchemeTxn> recoveryAmountSchemeTxnsIntial = getQueryFactory().select(qvRecoveryAmountSchemeTxn).from(qvRecoveryAmountSchemeTxn)
        .where(qvRecoveryAmountSchemeTxn.multiSchemeId.eq(scheme.getMultiSchemeId())).fetch();
    List<VRecoveryAmountSchemeTxn> recoveryAmountSchemeTxns = null;

    if (CollectionUtils.isNotEmpty(recoveryAmountSchemeTxnsIntial)) {
      recoveryAmountSchemeTxns = recoveryAmountSchemeTxnsIntial.stream().filter(new Predicate<VRecoveryAmountSchemeTxn>() {
        @Override
        public boolean test(VRecoveryAmountSchemeTxn t) {

          final Period thisPeriod = Period.parse(t.getTransactionWeek());
          return handlingFeePeriod.get(t.getCrpId()) != null && handlingFeePeriod.get(t.getCrpId()).contains(thisPeriod);
        }
      }).collect(Collectors.toList());

      // transformation
      final Map<String, List<VRecoveryAmountSchemeTxn>> recoveryAmountSchemeTxnGroupedByCRP = recoveryAmountSchemeTxns.stream()
          .collect(Collectors.groupingBy(VRecoveryAmountSchemeTxn::getCrpId));
      for (final Map.Entry<String, List<VRecoveryAmountSchemeTxn>> entry1 : recoveryAmountSchemeTxnGroupedByCRP.entrySet()) {
        final String crpId = entry1.getKey();
        final List<VRecoveryAmountSchemeTxn> transactions1 = entry1.getValue(); // recovery amount transactions for the CRP ID 

        if (!schemeParticipantMap.containsKey(crpId)) {
          MdtParticipantSite tempVal = getQueryFactory().select(QMdtParticipantSite.mdtParticipantSite).from(QMdtParticipantSite.mdtParticipantSite)
              .where(QMdtParticipantSite.mdtParticipantSite.siteNumber.eq(crpId)).fetchOne();

          schemeParticipantMap.put(crpId, tempVal);
        }

        final MdtParticipantSite crp = schemeParticipantMap.get(crpId);

        // transformation
        final Map<String, List<VRecoveryAmountSchemeTxn>> recoveryAmountSchemeTxnGroupedByWeek = transactions1.stream()
            .collect(Collectors.groupingBy(VRecoveryAmountSchemeTxn::getTransactionWeek));
        for (final Map.Entry<String, List<VRecoveryAmountSchemeTxn>> entry2 : recoveryAmountSchemeTxnGroupedByWeek.entrySet()) {
          final String week = entry2.getKey();
          final List<VRecoveryAmountSchemeTxn> transactions2 = entry2.getValue();
          for (final VRecoveryAmountSchemeTxn row : transactions2) {

            if (!periodMap.containsKey(week)) {
              Period tempPeriod = Period.parse(week);
              dateTimeSupport.setTerminalDates(tempPeriod);
              periodMap.put(week, tempPeriod);
            }
            final Period periodForTransaction = periodMap.get(week);
            final String arrear =
                currentPeriod.getStart().isEqual(periodForTransaction.getStart()) || currentPeriod.getStart().isBefore(periodForTransaction.getStart()) ? "N" : "Y";

            stale(thisBatch, crpId, row.getMaterialTypeId(), periodForTransaction, paymentType, paymentMethod, scheme);

            row.setGrossAmountSum(row.getVolume().multiply(getUnitSellingPrice(scheme, row.getMaterialTypeId())));
            //@formatter:off
          final PaymentTransactionRec paymentTransactionRec = buildRecovAmtSchmPayment(thisBatch
                                                                         , row
                                                                         , crp
                                                                         , materialTypeMap.get(row.getMaterialTypeId())
                                                                         , periodForTransaction
                                      
                                                                         , paymentType
                                                                         , paymentMethod
                                                                         , currentPeriod
                                                                         , arrear
                                                                         , scheme);
          //@formatter:on
            paymentTransactionRecords.add(paymentRepo.save(paymentTransactionRec));

          }

        }
      }
    }
    return recoveryAmountSchemeTxns;
  }

  /**
   * Merges elements from map1 and map2 together.
   * <p>If a key from map2 doesn't exist in map1, the key and value will be copied into the result.</p>
   * <p>If a key exists in both maps, the values will be combined together using the combiner operator.</p>
   * @param <K> The key class type
   * @param <V> The value class type
   * @param map1 Source map 1.
   * @param map2 Source map 2.
   * @param combiner An operator which will combine values together when a key exists in both both map1 and map2.
   * @return Returns a new map.
   */
  public <K, V> Map<K, V> merge(Map<K, V> map1, Map<K, V> map2, BinaryOperator<V> combiner) {

    final Map<K, V> map3 = new HashMap<>(map1);
    map2.forEach((k, v) -> map3.merge(k, v, combiner::apply));
    return map3;
  }

  //@formatter:off
    private PaymentTransactionRec buildRocovAmountSchAdjPayment(
                                              final PaymentBatch thisBatch,
                                              final VRecoveryAmountSchemeAdjustedTxn row,
                                              final MdtParticipantSite crp,       
                                              final MaterialType materialType, 
                                              final Period periodForTransaction,
                                              final String paymentType, 
                                              final String paymentMethod, 
                                              final Period currentPeriod,
                                              final String arrear,
                                              final Scheme scheme) {
    
    //@formatter:on
      final PaymentTransactionRec paymentTransactionRec = new PaymentTransactionRec();
      paymentTransactionRec.setId(UUID.randomUUID().toString());

      paymentTransactionRec.setPaymentType(paymentType);
      paymentTransactionRec.setPaymentMethod(paymentMethod);
      paymentTransactionRec.setPaymentBatch(thisBatch);
      paymentTransactionRec.setSchemeParticipantId(crp.getSiteNumber());
      MdtParticipant crpParticipant = crp.getParticipant();
      paymentTransactionRec.setSchemeParticipantName(crpParticipant.getParticipantName());
      paymentTransactionRec.setSchemeParticipantType(crp.getSiteType());
      paymentTransactionRec.setMaterialType(materialType);
      paymentTransactionRec.setPaymentPeriod(currentPeriod.toString());
      paymentTransactionRec.setPeriodType(periodForTransaction.getType().name());
      paymentTransactionRec.setPeriod(periodForTransaction.getValue());
      paymentTransactionRec.setEntryType(EntryType.A.name());
      paymentTransactionRec.setUnitSellingPrice(getUnitSellingPrice(scheme, materialType.getId()));
      paymentTransactionRec.setArrear(arrear); // derive arrear
      paymentTransactionRec.setGrossAmount(row.getVolume().multiply(getUnitSellingPrice(scheme, materialType.getId())));

      paymentTransactionRec.setTaxableAmount(BigDecimal.ZERO);
      paymentTransactionRec.setGstAmount(BigDecimal.ZERO);
      paymentTransactionRec.setLineType(LINE_TYPE);
      paymentTransactionRec.setVolume(row.getVolume());
      paymentTransactionRec.setUom(EA);
      paymentTransactionRec.setPaymentTimestamp(thisBatch.getStartTimeStamp());
      paymentTransactionRec.setStatus(PaymentTransactionRec.PaymentStatus.AWAITING_REVIEW);
      paymentTransactionRec.setScheme(scheme);

      return paymentTransactionRec;
    }

  //@formatter:off
    private PaymentTransactionRec buildRecovAmtSchmPayment(
                                              final PaymentBatch thisBatch,
                                              final VRecoveryAmountSchemeTxn row,
                                              final MdtParticipantSite crp,       
                                              final MaterialType materialType, 
                                              final Period periodForTransaction,
                                              final String paymentType, 
                                              final String paymentMethod, 
                                              final Period currentPeriod,
                                              final String arrear,
                                              Scheme scheme) {
    
    //@formatter:on

      final PaymentTransactionRec paymentTransactionRec = new PaymentTransactionRec();
      paymentTransactionRec.setId(UUID.randomUUID().toString());

      paymentTransactionRec.setPaymentType(paymentType);
      paymentTransactionRec.setPaymentMethod(paymentMethod);
      paymentTransactionRec.setPaymentBatch(thisBatch);
      paymentTransactionRec.setSchemeParticipantId(crp.getSiteNumber());
      MdtParticipant crpParticipant = crp.getParticipant();
      paymentTransactionRec.setSchemeParticipantName(crpParticipant.getParticipantName());
      paymentTransactionRec.setSchemeParticipantType(crp.getSiteType());
      paymentTransactionRec.setMaterialType(materialType);
      paymentTransactionRec.setPaymentPeriod(currentPeriod.toString());
      paymentTransactionRec.setPeriodType(periodForTransaction.getType().name());
      paymentTransactionRec.setPeriod(periodForTransaction.getValue());
      paymentTransactionRec.setEntryType(EntryType.R.name());
      paymentTransactionRec.setUnitSellingPrice(getUnitSellingPrice(scheme, materialType.getId()));
      paymentTransactionRec.setArrear(arrear); // derive arrear
      // QCRS-1290 : Instead of taking from pos calculating based in volume and unit selling price
      // paymentTransactionRec.setGrossAmount(row.getGrossAmountSum());
      paymentTransactionRec.setGrossAmount(row.getVolume().multiply(getUnitSellingPrice(scheme, materialType.getId())));

      paymentTransactionRec.setTaxableAmount(BigDecimal.ZERO);
      paymentTransactionRec.setGstAmount(BigDecimal.ZERO);
      paymentTransactionRec.setLineType(LINE_TYPE);
      paymentTransactionRec.setVolume(row.getVolume());
      paymentTransactionRec.setUom(EA);
      paymentTransactionRec.setPaymentTimestamp(thisBatch.getStartTimeStamp());
      paymentTransactionRec.setStatus(PaymentTransactionRec.PaymentStatus.AWAITING_REVIEW);
      paymentTransactionRec.setScheme(scheme);

      return paymentTransactionRec;
    }

  private PaymentTransactionRec buildRecovCashPayment(final PaymentBatch thisBatch, final VRecoveryAmountCashTxn row, final MdtParticipantSite crp, final MaterialType materialType,
      final Period periodForTransaction, final String paymentType, final String paymentMethod, final Period currentPeriod, final String arrear, Scheme scheme) {

    final PaymentTransactionRec paymentTransactionRec = new PaymentTransactionRec();
    paymentTransactionRec.setId(UUID.randomUUID().toString());

    paymentTransactionRec.setPaymentType(paymentType);
    paymentTransactionRec.setPaymentMethod(paymentMethod);
    paymentTransactionRec.setPaymentBatch(thisBatch);
    paymentTransactionRec.setSchemeParticipantId(crp.getSiteNumber());
    MdtParticipant crpParticipant = crp.getParticipant();
    paymentTransactionRec.setSchemeParticipantName(crpParticipant.getParticipantName());
    paymentTransactionRec.setSchemeParticipantType(crp.getSiteType());
    paymentTransactionRec.setMaterialType(materialType);
    paymentTransactionRec.setPaymentPeriod(currentPeriod.toString());
    paymentTransactionRec.setPeriodType(periodForTransaction.getType().name());
    paymentTransactionRec.setPeriod(periodForTransaction.getValue());
    paymentTransactionRec.setEntryType(EntryType.R.name());
    BigDecimal unitSellingPrice = getUnitSellingPrice(scheme, materialType.getId());
    paymentTransactionRec.setUnitSellingPrice(unitSellingPrice);
    paymentTransactionRec.setArrear(arrear); // derive arrear
    // QCRS-1290 : Instead of taking from pos calculating based in volume and unit selling price
    // paymentTransactionRec.setGrossAmount(row.getGrossAmountSum());
    paymentTransactionRec.setGrossAmount(row.getVolume().multiply(unitSellingPrice));

    paymentTransactionRec.setTaxableAmount(BigDecimal.ZERO);
    paymentTransactionRec.setGstAmount(BigDecimal.ZERO);
    paymentTransactionRec.setLineType(LINE_TYPE);
    paymentTransactionRec.setVolume(row.getVolume());
    paymentTransactionRec.setUom(EA);
    paymentTransactionRec.setPaymentTimestamp(thisBatch.getStartTimeStamp());
    paymentTransactionRec.setStatus(PaymentTransactionRec.PaymentStatus.AWAITING_REVIEW);
    paymentTransactionRec.setScheme(scheme);

    return paymentTransactionRec;
  }

  private PaymentTransactionRec buildRecovAmtCashAdjPayment(final PaymentBatch thisBatch, final VRecoveryAmountCashAdjustedTxn row, final MdtParticipantSite crp, final MaterialType materialType,
      final Period periodForTransaction, final String paymentType, final String paymentMethod, final Period currentPeriod, final String arrear, Scheme scheme) {

    final PaymentTransactionRec paymentTransactionRec = new PaymentTransactionRec();
    paymentTransactionRec.setId(UUID.randomUUID().toString());

    paymentTransactionRec.setPaymentType(paymentType);
    paymentTransactionRec.setPaymentMethod(paymentMethod);
    paymentTransactionRec.setPaymentBatch(thisBatch);
    paymentTransactionRec.setSchemeParticipantId(crp.getSiteNumber());
    MdtParticipant crpParticipant = crp.getParticipant();
    paymentTransactionRec.setSchemeParticipantName(crpParticipant.getParticipantName());
    paymentTransactionRec.setSchemeParticipantType(crp.getSiteType());
    paymentTransactionRec.setMaterialType(materialType);
    paymentTransactionRec.setPaymentPeriod(currentPeriod.toString());
    paymentTransactionRec.setPeriodType(periodForTransaction.getType().name());
    paymentTransactionRec.setPeriod(periodForTransaction.getValue());
    paymentTransactionRec.setEntryType(EntryType.A.name());
    BigDecimal unitSellingPrice = getUnitSellingPrice(scheme, materialType.getId());
    paymentTransactionRec.setUnitSellingPrice(unitSellingPrice);
    paymentTransactionRec.setArrear(arrear); // derive arrear
    paymentTransactionRec.setGrossAmount(row.getVolume().multiply(unitSellingPrice));
    paymentTransactionRec.setTaxableAmount(BigDecimal.ZERO);
    paymentTransactionRec.setGstAmount(BigDecimal.ZERO);
    paymentTransactionRec.setLineType(LINE_TYPE);
    paymentTransactionRec.setVolume(row.getVolume());
    paymentTransactionRec.setUom(EA);
    paymentTransactionRec.setPaymentTimestamp(thisBatch.getStartTimeStamp());
    paymentTransactionRec.setStatus(PaymentTransactionRec.PaymentStatus.AWAITING_REVIEW);
    paymentTransactionRec.setScheme(scheme);

    return paymentTransactionRec;
  }

  private PaymentTransactionRec buildPayment(final PaymentBatch thisBatch, final VGstRecoverySchemeTxn row, final MdtParticipantSite crp, final MaterialType materialType,
      final Period periodForTransaction, final String paymentType, final String paymentMethod, final Period currentPeriod, final String arrear, Scheme scheme) {

    final PaymentTransactionRec paymentTransactionRec = new PaymentTransactionRec();
    paymentTransactionRec.setId(UUID.randomUUID().toString());

    paymentTransactionRec.setPaymentType(paymentType);
    paymentTransactionRec.setPaymentMethod(paymentMethod);
    paymentTransactionRec.setPaymentBatch(thisBatch);
    paymentTransactionRec.setSchemeParticipantId(crp.getSiteNumber());
    MdtParticipant crpParticipant = crp.getParticipant();
    paymentTransactionRec.setSchemeParticipantName(crpParticipant.getParticipantName());
    paymentTransactionRec.setSchemeParticipantType(crp.getSiteType());
    paymentTransactionRec.setMaterialType(materialType);
    paymentTransactionRec.setPaymentPeriod(currentPeriod.toString());
    paymentTransactionRec.setPeriodType(periodForTransaction.getType().name());
    paymentTransactionRec.setPeriod(periodForTransaction.getValue());
    paymentTransactionRec.setEntryType(EntryType.R.name());
    paymentTransactionRec.setUnitSellingPrice(new BigDecimal(1));
    paymentTransactionRec.setArrear(arrear); // derive arrear
    paymentTransactionRec.setGrossAmount(row.getGstRecoverySum());
    paymentTransactionRec.setTaxableAmount(BigDecimal.ZERO);
    paymentTransactionRec.setGstAmount(BigDecimal.ZERO);
    paymentTransactionRec.setLineType(LINE_TYPE);
    paymentTransactionRec.setVolume(row.getGstRecoverySum());
    paymentTransactionRec.setUom(EA);
    paymentTransactionRec.setPaymentTimestamp(thisBatch.getStartTimeStamp());
    paymentTransactionRec.setStatus(PaymentTransactionRec.PaymentStatus.AWAITING_REVIEW);
    paymentTransactionRec.setScheme(scheme);

    return paymentTransactionRec;
  }

  private PaymentTransactionRec buildCollecFeesPayment(final PaymentBatch thisBatch, final CollectionFeeValue row, final MdtParticipantSite crp, final MaterialType materialType,
      final Period periodForTransaction, final String paymentType, final String paymentMethod, final Period currentPeriod, final String arrear, Scheme scheme) {

    final PaymentTransactionRec paymentTransactionRec = new PaymentTransactionRec();
    paymentTransactionRec.setId(UUID.randomUUID().toString());

    paymentTransactionRec.setPaymentType(paymentType);
    paymentTransactionRec.setPaymentMethod(paymentMethod);
    paymentTransactionRec.setPaymentBatch(thisBatch);
    paymentTransactionRec.setSchemeParticipantId(crp.getSiteNumber());
    MdtParticipant crpParticipant = crp.getParticipant();
    paymentTransactionRec.setSchemeParticipantName(crpParticipant.getParticipantName());
    paymentTransactionRec.setSchemeParticipantType(crp.getSiteType());
    paymentTransactionRec.setMaterialType(materialType);
    paymentTransactionRec.setPaymentPeriod(currentPeriod.toString());
    paymentTransactionRec.setPeriodType(periodForTransaction.getType().name());
    paymentTransactionRec.setPeriod(periodForTransaction.getValue());
    paymentTransactionRec.setEntryType(EntryType.R.name());
    BigDecimal unitSellingPrice = getUnitSellingPrice(scheme, materialType.getId());
    paymentTransactionRec.setUnitSellingPrice(unitSellingPrice);
    paymentTransactionRec.setArrear(arrear); // derive arrear
    paymentTransactionRec.setGrossAmount(row.getVolume().multiply(unitSellingPrice));

    paymentTransactionRec.setTaxableAmount(row.getTaxableAmountSum());
    paymentTransactionRec.setGstAmount(row.getGstAmountSum());
    paymentTransactionRec.setLineType(LINE_TYPE);
    paymentTransactionRec.setVolume(row.getVolume());
    paymentTransactionRec.setUom(EA);
    paymentTransactionRec.setPaymentTimestamp(thisBatch.getStartTimeStamp());
    paymentTransactionRec.setStatus(PaymentTransactionRec.PaymentStatus.AWAITING_REVIEW);
    paymentTransactionRec.setScheme(scheme);

    return paymentTransactionRec;
  }

  /**
   * Existing transactions matching the scheme participant ID, material type ID, period type, payment type, payment method, period, payment batch ID, an entry type of R (regular) and a status of AWAITING_REVIEW are updated
   * with a STALE payment status.  
   * @param thisBatch
   * @param crpId
   * @param materialTypeId
   * @param periodForTransaction
   * @param paymentType
   * @param paymentMethod
   */
  private void stale(final PaymentBatch thisBatch, final String crpId, final String materialTypeId, final Period periodForTransaction, String paymentType, String paymentMethod, Scheme scheme) {

    final QPaymentTransactionRec qPaymentTransactionRec = QPaymentTransactionRec.paymentTransactionRec;
    //@formatter:off
    final List<PaymentTransactionRec> oldPaymentTransactionRecs = getQueryFactory().select(qPaymentTransactionRec)
                                                                               .from(qPaymentTransactionRec)
                                                                             .where(qPaymentTransactionRec.schemeParticipantId.eq(crpId)
                                                                              .and(qPaymentTransactionRec.materialType.id.eq(materialTypeId))
                                                                              .and(qPaymentTransactionRec.periodType.eq(periodForTransaction.getType().name()))
                                                                              .and(qPaymentTransactionRec.paymentType.eq(paymentType))
                                                                              .and(qPaymentTransactionRec.paymentMethod.eq(paymentMethod))
                                                                              .and(qPaymentTransactionRec.period.eq(periodForTransaction.getValue()))
                                                                              .and(qPaymentTransactionRec.entryType.eq(EntryType.R.name()))
                                                                              .and(qPaymentTransactionRec.paymentBatch.id.ne(thisBatch.getId()))
                                                                              .and(qPaymentTransactionRec.status.eq(PaymentTransactionRec.PaymentStatus.AWAITING_REVIEW))
                                                                              .and(qPaymentTransactionRec.scheme.eq(scheme))
                                                                              ).fetch();
    
    oldPaymentTransactionRecs.stream().forEach(x -> {
      x.setStatus(PaymentTransactionRec.PaymentStatus.STALE);
      paymentRepo.save(x);
    });
  }

  /**
   * Returns a particular hard coded unit selling price for all materials except for INELIGIBLE_MATERIAL_TYPE.
   * 
   * <p>For a martial type of INELIGIBLE_MATERIAL_TYPE, zero is returned.</p>
   * 
   * @param materialTypeId The ID of the material type to obtain a unit selling price for .
   * @return Returns either UNIT_SELLING_PRICE, or zero.
   */
  private BigDecimal getUnitSellingPrice(Scheme scheme, String materialTypeId) {
    if(StringUtils.equals(materialTypeId, INELIGIBLE_MATERIAL_TYPE) || StringUtils.endsWith(materialTypeId, "_" + INELIGIBLE_MATERIAL_TYPE)) {
      return BigDecimal.ZERO;
    }
    return getUnitSellingPrice(scheme);
  }
  
  private BigDecimal getUnitSellingPrice(Scheme scheme) {
    return schemeRefCodeService.getValueAsBigDecimal(SchemeRefCodes.FeesAndPrices.CATEGORY, SchemeRefCodes.FeesAndPrices.CRP_UNIT_SELLING_PRICE, scheme.getId(), BigDecimal.ZERO);
  }
  
  private JPAQueryFactory getQueryFactory() {
    final JPAQueryFactory factory = new JPAQueryFactory(em);
    return factory;
  }

}
